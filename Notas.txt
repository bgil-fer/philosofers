
Estructura conceptual del programa de los fil√≥sofos comensales (sin variables globales):

1. Lectura y validaci√≥n de par√°metros:
   - number_of_philosophers
   - time_to_die
   - time_to_eat
   - time_to_sleep
   - number_of_times_each_philosopher_must_eat (opcional)
   ‚Üí Todos estos par√°metros se encapsulan en una estructura de configuraci√≥n (por ejemplo, t_config).

2. Inicializaci√≥n de estructuras:
   - Se crea una estructura principal (t_simulation) que contiene:
     ‚Ä¢ La configuraci√≥n del programa (datos de argv)
     ‚Ä¢ Array de fil√≥sofos (t_philosopher)
     ‚Ä¢ Array de mutexes para los tenedores
     ‚Ä¢ Mutex para impresi√≥n en consola
     ‚Ä¢ Mutex para control de estado (por ejemplo, si alguien ha muerto)
     ‚Ä¢ Tiempo de inicio de la simulaci√≥n
   ‚Üí Esta estructura se pasa por puntero a todas las funciones y hilos que la necesiten.

3. Creaci√≥n de hilos:
   - Se lanza un hilo por cada fil√≥sofo.
   - Cada hilo recibe un puntero a su propia estructura t_philosopher, que incluye un puntero a t_simulation.

4. Ciclo de vida del fil√≥sofo:
   - Pensar
   - Tomar tenedores (bloqueo de mutexes)
   - Comer (actualiza tiempo de √∫ltima comida, incrementa contador, espera time_to_eat)
   - Soltar tenedores (desbloqueo de mutexes)
   - Dormir (espera time_to_sleep)
   - Volver a pensar

5. Monitor de muerte:
   - Hilo separado que recorre peri√≥dicamente todos los fil√≥sofos.
   - Verifica si alguno ha superado time_to_die desde su √∫ltima comida.
   - Si detecta una muerte:
     ‚Ä¢ Imprime el mensaje correspondiente
     ‚Ä¢ Actualiza el estado de la simulaci√≥n (por ejemplo, bandera de "terminado") usando mutex

6. Finalizaci√≥n del programa:
   - Si se especifica number_of_times_each_philosopher_must_eat, el programa termina cuando todos han comido suficiente.
   - Se espera a que todos los hilos terminen.
   - Se destruyen los mutexes y se libera la memoria.

Resumen de componentes (sin variables globales):

| Componente                      | Rol                                                    |
|-------------------------------|---------------------------------------------------------|
| t_config                       | Contiene los par√°metros del programa                   |
| t_simulation                   | Estructura principal con todos los recursos compartidos|
| t_philosopher                  | Estructura individual por fil√≥sofo                     |
| Mutexes                        | Tenedores, impresi√≥n, control de estado                |
| Hilos                          | Uno por fil√≥sofo + uno monitor                         |
| Comunicaci√≥n entre estructuras| Se hace por punteros, nunca por variables globales     |



INICIAIZAR ESTRUCTURA SIMULATION

üîπ 1. Validar par√°metros de entrada
[X] Leer los argumentos del usuario (n√∫mero de fil√≥sofos, tiempos, etc.).

[X] Verificar que todos los valores sean positivos y coherentes.

[X] Crear la estructura t_config con los valores validados.

üîπ 2. Crear la estructura t_simulation
[X] Declarar la estructura t_simulation (como puntero o variable local).

[X] Asociar el puntero a t_config dentro de t_simulation.

üîπ 3. Reservar memoria din√°mica
[x] Reservar memoria para el array de fil√≥sofos (t_philosopher[]).

[x] Reservar memoria para el array de tenedores (pthread_mutex_t[]).

üîπ 4. Inicializar mutexes
[ ] Inicializar cada mutex del array de tenedores.

[ ] Inicializar el mutex de impresi√≥n (print_mutex).

[ ] Inicializar el mutex de estado (state_mutex).

üîπ 5. Inicializar fil√≥sofos
[ ] Asignar ID √∫nico a cada fil√≥sofo.

[ ] Asignar tenedor izquierdo y derecho.

[ ] Inicializar contador de comidas y tiempo de √∫ltima comida.

[ ] Asociar el puntero a t_simulation en cada fil√≥sofo.

üîπ 6. Registrar tiempo de inicio
[ ] Obtener el tiempo actual (por ejemplo, con gettimeofday).

[ ] Guardar ese valor en start_time dentro de t_simulation.

üîπ 7. Verificar que todo est√© listo
[ ] Comprobar que todas las reservas de memoria fueron exitosas.

[ ] Comprobar que todos los mutexes est√°n correctamente inicializados.

[ ] Comprobar que cada fil√≥sofo tiene sus tenedores asignados.